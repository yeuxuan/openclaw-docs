# 35 函数级剖析 运维方法组与控制面补全

核心文件（方法组）：
- `health.ts` `logs.ts` `models.ts` `usage.ts`
- `cron.ts` `wizard.ts` `talk.ts` `tts.ts`
- `web.ts` `browser.ts` `system.ts`

## 步骤一：执行链路拆解（按运维场景）

1. 健康与状态
- `health` / `status`

2. 诊断与观察
- `logs.tail`
- `models.list`
- `usage.status` / `usage.cost` / `sessions.usage*`

3. 自动任务与向导
- `wake` / `cron.*`
- `wizard.*`

4. 语音与对话控制
- `talk.config` / `talk.mode`
- `tts.*`
- `voicewake.*`（在 `voicewake.ts`）

5. Web 与浏览器控制
- `web.login.start/wait`
- `browser.request`

6. 系统事件与在场信息
- `system-presence`
- `system-event`
- `last-heartbeat` / `set-heartbeats`

## 步骤二：细粒度拆解（关键点）

### A. `health` 的缓存+后台刷新

`health` 默认优先返回缓存（60 秒窗口），同时后台刷新。  
如果 `probe=true`，会走更重的探测路径。

### B. `logs.tail` 的游标读取

`logs.tail` 支持 cursor 增量读取，并处理：
- 文件滚动
- 游标失效（文件截断/轮转）
- bytes 与 lines 上限

这让前端日志面板可以低成本持续追踪。

### C. `usage` 的聚合成本较高，所以有缓存

`usage.cost` / `sessions.usage` 会做时间范围聚合。  
代码里用了 30 秒缓存和 in-flight 共享，避免重复重算。

### D. `cron.*` 的 schedule 校验

`cron.add/update` 会先规范化，再验证 timestamp/schedule。  
`cron.runs` 读取独立 run log，适合排查定时任务异常。

### E. `wizard.*` 的会话状态机

`wizard.start` 创建一个 `WizardSession`，后续 `next/cancel/status` 操作同一个 sessionId。  
只有一个向导能运行，避免配置流程互相覆盖。

### F. `talk/tts/voicewake`

- `talk.mode` 在 webchat 场景会检查是否有移动节点在线。
- `tts.status/providers` 暴露 provider 配置与可用性。
- `voicewake.set` 更新触发词并广播 `voicewake.changed`。

### G. `web.login.*` 与 `browser.request`

`web.login.*` 通过 channel plugin 的 QR 能力完成网页登录。  
`browser.request` 优先走 browser-capable node（远端代理）；无节点时回退到本地 browser control service。

### H. `system-event` 的存在感广播

`system-event` 不只是写一行文本，它还会：
- 更新 presence
- 比较上下文变化（减少噪音）
- 广播全局 `presence` 事件


