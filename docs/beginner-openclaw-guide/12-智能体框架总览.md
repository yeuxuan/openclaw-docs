# 12 智能体框架总览

## 模块目标

把 OpenClaw 的“智能体核心引擎”先看成一个整体，再进入各子模块细拆。

## Agent 执行链路全景图

```mermaid
flowchart TD
  A[chat.send / auto-reply] --> B[runEmbeddedPiAgent]

  subgraph 队列层
    B --> C[resolveSessionLane]
    B --> D[resolveGlobalLane]
    C --> E[enqueueCommandInLane<br/>Session 队列]
    D --> E
  end

  subgraph 模型解析
    E --> F[resolveModel<br/>provider + modelId]
    F --> G[resolveAuthProfileOrder<br/>API Key 轮转]
  end

  subgraph 主循环["主循环 (while true)"]
    G --> H[runEmbeddedAttempt]

    H --> H1[loadWorkspaceSkillEntries<br/>技能加载]
    H --> H2[createOpenClawCodingTools<br/>工具集构建]
    H --> H3[buildEmbeddedSystemPrompt<br/>系统提示词]
    H --> H4[SessionManager.open<br/>打开会话]

    H1 --> I[hookRunner.runBeforeAgentStart]
    H2 --> I
    H3 --> I
    H4 --> I

    I --> J[activeSession.prompt<br/>LLM 流式调用]
    J --> K[subscribeEmbeddedPiSession<br/>事件订阅]
    K --> L{结果判断}
  end

  L -->|成功| M[buildEmbeddedRunPayloads<br/>回复拼装 → 发回通道]
  L -->|contextOverflow| N[compactSession<br/>上下文压缩] --> H
  L -->|promptError| O[advanceAuthProfile<br/>切换 Key] --> H
  L -->|thinkingUnsupported| P[pickFallbackThinkingLevel] --> H

  style A fill:#f0a500,color:#000
  style M fill:#0891b2,color:#fff
  style N fill:#ef4444,color:#fff
  style O fill:#ef4444,color:#fff
  style P fill:#ef4444,color:#fff
```

## 步骤一：实现拆解（执行链路）

1. 上层入口:
- `src/commands/agent.ts`
- `src/auto-reply/reply/agent-runner-execution.ts`

2. 核心执行入口:
- `src/agents/pi-embedded.ts`
- `src/agents/pi-embedded-runner.ts`
- `src/agents/pi-embedded-runner/run.ts`

3. 核心子系统:
- 运行尝试: `src/agents/pi-embedded-runner/run/attempt.ts`
- 工具系统: `src/agents/pi-tools.ts`, `src/agents/openclaw-tools.ts`
- 流式事件: `src/agents/pi-embedded-subscribe.ts`
- 并发模型: `src/agents/pi-embedded-runner/lanes.ts`, `src/process/command-queue.ts`
- 子智能体: `src/agents/tools/sessions-spawn-tool.ts`, `src/agents/subagent-registry.ts`
- 技能系统: `src/agents/skills.ts`, `src/agents/skills/refresh.ts`
- 失败恢复: `src/agents/model-fallback.ts`, `src/agents/pi-embedded-runner/run.ts`

## 步骤二：细粒度讲解（小白版）

1. 这套框架的职责是“把一次用户请求跑完”
- 选模型与认证
- 组装 system prompt + skills + tools
- 流式执行并回传片段
- 处理错误、超时、压缩、回退

2. 这是“多层编排”而不是“一个大函数”
- 上层决定什么时候跑
- 中层决定怎么跑（队列、lane、session）
- 下层负责具体执行（PI session + 工具调用）

3. 它是“状态机 + 事件流”
- 生命周期事件: start/update/end/error
- tool 事件与 assistant 文本事件并行
- 最终由上层转成对外回复 payload


